#Descrição detalhada do trabalho
A arquitetura do sistema proposto no projeto é composta por diversas estações agrometeorológicas, cada uma equipada com um conjunto de sensores. Dentre eles, alguns desses captarão os aspectos de luminosidade da região ao longo do tempo. A leitura dos sensores e a conversão da informação são realizadas por um sistema microcontrolado ARM, responsável não apenas pela captura, mas também pelo armazenamento e transmissão desses dados. Em sua etapa inicial de planejamento a base de leitura e gravação dos dados sensoriais ficaria a cargo de um sistema microcontrolado, utilizando a plataforma Arduino.
A escolha da plataforma Arduino foi natural, por sua facilidade de manuseio, vasto material de apoio (documentação, trabalhos etc.), seu suporte as mais diversas ferramentas (sensores, Shields), facilidade de programação e seu baixo custo. O sensor de luminosidade (LDR), o qual exerce um papel importante, uma vez que fornece um parâmetro que exerce um papel crucial no desenvolvimento de certas culturas e colabora na determinação precisa do período de dia e noite para as plantas, precisaria de um cuidado especial no seu manuseio.
Os primeiros testes iniciaram com a construção de diversos códigos para o sensor de luminosidade a fim de compreender o seu funcionamento, sua faixa de valores e como o Arduino realizaria o trabalho. O LDR é um sensor analógico (trabalha com comprimentos de onda), o Arduino então realiza a conversão analógico-digital e representa os valores de luminosidade em uma faixa de 0 a 1023. 
Foi criada uma miniestação fixa com vários LDR’s organizados em uma geometria semelhante a uma forma radial. O circuito do LDR é montado em uma protoboard e ligado ao Arduino. O LDR capta a luminosidade local e, via comunicação serial, apresenta os dados no monitor do Arduino IDE.
É utilizado também o protocolo de comunicação SPI (Serial Peripheral Interface) que permite a comunicação do microcontrolador com diversos outros componentes, formando uma rede, utilizando a biblioteca SPI.h, que trabalha baseado no conceito multi-mestre, onde todos os módulos podem se tornar mestre em determinado momento e escravo em outro, além de suas mensagens serem enviadas em regime multicast (entrega de informação para múltiplos destinatários simultaneamente), caracterizado pelo envio de toda e qualquer mensagem para todos os módulos existentes na rede. O armazenamento é feito em um Cartão de Memória SD Card. 
Outro componente de bastante importância para o circuito é o RTC (Real Time Clock), que armazena a data e hora local. Tal componente oferece à miniestação alta precisão e consistência dos dados, uma vez que as informações coletadas, agora, podem ser cruzadas sendo possível correlaciona-las no tempo. O Arduino não possui um RTC próprio, sendo necessário utilizar um externo, através do barramento I²C que possui a linha direcional de Dados Seriais.
O código final é baseado no trabalho desses três componentes juntos (LDR, SD Card e RTC). Inicialmente são declaradas algumas variáveis, inclusive um do tipo FILE. Os componentes são inicializados na função setup (). Nela o RTC ajusta a data e a hora e o SD Card é averiguado para confirmar seu funcionamento, caso contrário uma mensagem é emitida não sendo possível guardar os dados captados.
No caso da função loop (), uma variável de controle utilizada para se determinar o sensor LDR que será lido é inicializada. A cada iteração, seu valor vai de 0 a 3, indicando cada sensor. Um arquivo csv (do inglês, Comma Separated Values) armazena os dados coletados. Nele cada ponto e vírgula representa uma célula diferente de uma planilha e é posível abrir o arquivo em uma planilha eletrônica como MS Excel ou LibreOffice Calc. Ao fim do laço o arquivo é fechado e o processo é iniciado novamente após um período de dois segundos. A captação e gravação ocorrerão enquanto o microcontrolador estiver ligado a uma fonte de alimentação de no máximo 5V. Dentro e fora do laço são emitidas mensagens através da porta serial a fim de uma melhor compreensão do processo de captura. 
#Conversão do código do Arduino UNO para o Tiva C Series TM4C123G LaunchPad
O ambiente de programação do Tiva é similar ao ambiente do Arduíno, com bibliotecas semelhantes, porém devido à diferença de microcontrolador, o endereçamento das portas é diferenciado. Isso obriga que sejam feitas algumas alterações nas bibliotecas utilizadas no Arduino. O Tiva C possui menos entradas analógicas, porém o suficiente para a quantidade de LDR’s necessária.
O Arduino trabalha com a biblioteca SD, default do próprio ambiente de desenvolvimento. O projeto, com Arduino, utiliza uma shield, com as portas default da bilbioteca. Com a passagem para o Tiva, essa shield pode ser substituída por um adaptador SD, Além disso, as portas SPI do Tiva são diferentes, o que força a realização de adaptações na biblioteca SD para portá-la à nova plataforma. A partir da versão para Arduino, é necessário copiá-la da pasta de bibliotecas do Energia, por exemplo “C:\Users\Usuário\Pasta\energia-0101E0012\hardware\lm4f\libraries”, onde a pasta lm4f corresponde ao hardware utilizado. Na pasta original do SD existe outra pasta chamada src, uma vez copiada essa pasta deve deixar de existir, então seu conteúdo deve ser colocado na pasta externa. 
Na pasta utility há um arquivo chamado Sd2PinMap.h onde deve-se alterar as portas do barramento SPI para uso com SD Card . A   9 apresenta o trecho de código original do Arduíno, que para uso no Tiva deve ser alterado.
Com relação ao RTC, o Tiva possui um próprio, o que obriga apenas a alterar-se o modelo de RTC_DS1307 para RTC_Millis na biblioteca derivada do Arduino. Copia-se essa biblioteca para a pasta de bibliotecas do Energia, seguindo os mesmos passos utilizados no caso da biblioteca do SD.
Contudo é recomendado utilizar um RTC externo, pois o nativo do microcontrolador ocupa o mesmo barramento que os outros componentes, podendo causar erros na geração de datas e horários.

